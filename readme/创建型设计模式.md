# 创建型设计模式

## 简单工厂
1. 定义：由一个工厂对象决定创建出哪一种产品类的实例。
2. 类型：创建型，但不属于GOF23种设计模式。
3. 适用场景：    
    (1)工厂类负责创建的对象比较少；   
    (2)客户端（应用层）只知道传入工厂类的参数对于如何创建对象（逻辑）不关心。  
4. 优点：  
    (1)只需要传入一个正确的参数，就可以获取你所需要的对象而无需知道其创建细节；
5. 缺点：  
    (1)工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则；    
    (2)无法形成基于继承的等级结构。   

## 工厂方法
1. 定义：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。   
2. 类型：创建型。  
3. 适用场景：    
    (1)创建对象需要大量重复的代码；   
    (2)客户端（应用层）不依赖于产品类实例如何被创建、实现等细节；    
    (3)一个类通过其子类来指定创建哪个对象。   
4. 优点：  
    (1)用户只需要关心所需产品对应的工厂，无需关心创建细节；   
    (2)加入新产品符合开闭原则，提高可扩展性。      
5. 缺点：      
    (1)类的个数容易过多，增加复杂度；      
    (2)增加了系统的抽象性和理解难度。      
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/factorymethod.jpg" width="100%" height="689"/>

## 抽象工厂
1. 定义：抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。      
2. 无需指定它们具体的类。      
3. 类型：创建型。      
4. 适用场景：    
    (1)客户端（应用层）不依赖产品类实例如何被创建、实现等细节；     
    (2)强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码；         
    (3)提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖与具体实现。             
5. 优点：      
    (1)具体产品在应用层代码隔离，无须关心创建细节；   
    (2)将一个系列的产品族统一到一起创建；    
6. 缺点：  
    (1)规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；    
    (2)增加了系统的抽象性和理解难度。      
7. 抽象工厂 - 产品等级结构与产品族
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/produceseries.jpg" width="100%" height="648"/>
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/productseries2.jpg" width="100%" height="648"/>
8. 抽象工厂UML图
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/abstractfactory.jpg" width="495" height="690"/>
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/abstractfactory2.jpg" width="100%" height="648"/>

## 建造者模式
1. 定义：将一个复杂对的的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。     
2. 用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。       
3. 类型：创建型。      
4. 适用场景：    
    (1)如果一个对象有非常复杂的内部结构（很多属性）；      
    (2)想把复杂对象的创建和使用分离。      
5. 优点：      
    (1)封装性好，创建和使用分离；        
    (2)扩展性好、建造类之间独立、一定程度上解耦。        
6. 缺点：      
    (1)产生多余的Builder对象；      
    (2)产品内部发生变化，建造者都要修改，成本较大        
7. 建造者模式和工厂模式区别：        
    (1)建造者模式注重于方法的调用顺序，而工厂模式更注重创建产品；        
    (2)创建对象的粒度不同，建造者模式用于创建一些复杂的产品，由各种复杂的部件组成，工厂模式创建出来       
        的都是一个样子，工厂模式关注着只要把这个对象创建出来，而建造者模式不仅要创建出来哪种产品，还      
        要知道这个产品由哪些部件组成。     
        
## 单例模式
1. 定义：保证一个类仅有一个实例，并提供一个全局访问点。         
2. 类型：创建型。      
3. 适用场景：        
    (1)想确保任何情况下都绝对只有一个实例；       
4. 优点：      
    (1)在内存里只有一个实例，减少了内存开销；      
    (2)可以避免对资源的多重占用；        
    (3)设置全局访问点，严格控制访问。      
5. 缺点：      
    (1)没有接口，扩展困难；       
6. 重点：      
    (1)私有构造器；       
    (2)线程安全；        
    (3)延迟加载；        
    (4)序列化和反序列化安全；      
    (5)反射       
7. 实用技能     
    (1)反编译      
    (2)内存原理     
    (3)多线程Debug     
8. 单例--相关设计模式       
    (1)单例模式和工厂模式；       
    (2)单例模式和享元模式；       
9. 单例模式种类       
    (1)懒汉式      
    (2)DCL      
    (3)静态内部类，其基于类的初始化的延迟加载解决方案。     
        根据Java语言规范，主要分5种情况，首次发生的时候，一个类将被立刻初始化：      
        .有一个A类型的实例被创建；      
        .A类中声明的一个静态方法被调用；       
        .A类中声明的一个静态成员被赋值；       
        .A类中的一个静态成员被使用，并且这个成员不是一个常亮成员；      
        .A类是个顶级类，并且在这个类中有嵌套的断言语句；       
<img src="https://github.com/JeremyHwc/JDesignPattern/blob/master/readme/pic/staticinnerclass.jpg" width="100%" height="689"/>




